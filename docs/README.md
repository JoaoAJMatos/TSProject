# IPLChat

IPLChat is an implementation of a __secure chat application__ using the client-server model. It is built on top of the [ProtoIP](https://joaoajmatos.github.io/ProtoIP/#) library, which provides an easy-to-use API for building fast and simple network applications. The project was developed as part of the __Security Topics__ course of the __PSI-TESP__ at the __Polytechnic Institure of Leiria__.

This directory contains the documentation for the project, hopefully guiding the reader through the codebase and explaining the design decisions made along the way.

## Table of Contents

- [IPLChat](#iplchat)
  - [Table of Contents](#table-of-contents)
  - [Project Structure](#project-structure)
  - [Protocol](#protocol)
    - [Messages](#message-types)
    - [Message Structure](#message-structure)
  - [Server](#server)
    - [Server Design](#server-design)
    - [Server Flow](#server-flow)
    - [Database](#database)
    - [CLI](#server-cli)
  - [Client](#client)
    - [Client Design](#client-states)
    - [Client Flow](#client-flow)
  - [Security](#security)
    - [Authentication](#authentication)
    - [Confidentiality](#confidentiality)
    - [Integrity](#integrity)
    - [Non-Repudiation](#non-repudiation)
  - [Future Work](#future-work)
  - [References](#references)

## Project Structure

The project is divided into two main parts: the __client__ and the __server__. The client contains all of the code related to the client-side of the application, while the server contains all of the code related to the server-side of the application. The server also contains a __CLI__ (Command Line Interface) for managing the server just like a server administrator would.

The client-side implements all the functionality related to the user interface, such as the login and registration forms, the chat window, and the user list. It also implements the client-side of the protocol, which is responsible for sending and receiving messages from the server.

The server-side implements all the functionality related to the server, such as the server-side of the protocol, the database, and the CLI. It is responsible for handling requests and forwarding messages to the clients.

## Protocol

The protocol is the set of rules that govern the communication between the client and the server. It defines the structure of the messages exchanged between the two parties, as well as the order in which they are exchanged. The protocol is defined on both the client-side and the server-side of the application and can be found in the [Protocol.cs](../Protocol.cs) file.

All the __control messages__ and requests are sent in the form of [ProtoPackets](https://joaoajmatos.github.io/ProtoIP/#/Packet) as defined in the __ProtoIP__ library.

### Message Types

The protocol defines 2 types of messages: __text messages__ and __file transfers__. Text messages are used for sending text messages between users, while file transfers are used for sending files between users. Both types of messages are sent in the form of [ProtoPackets](https://joaoajmatos.github.io/ProtoIP/#/Packet) as defined in the __ProtoIP__ library. For this reason, the size of the text messages is limitted to the maximum size of a ProtoPacket payload.

### Message Structure

The protocol defines the structure of the messages exchanged between the client and the server. The structure of the messages is defined in the [Protocol.cs](../Protocol.cs) file and is as follows:

```csharp
public string _senderID  { get; set; } // UUID of the sender
public string _channelID { get; set; } // UUID of the destination channel
public byte[] _message { get; set; }   // Message bytes
public byte[] _signature { get; set; } // Message signature
public Type _type { get; set; }        // Message type (text or file)
```

Each peer in the network is identified by it's __Universally Unique Identifier__ (UUID). This UUID is generated by the server when the user registers and is used to identify it in the network. The UUID is used to identify the sender of the message, as well as the destination channel (or user) of the message.

## Server

The server is responsible for handling requests from the clients and forwarding messages between them. It is also responsible for managing the database and the CLI.

### Server Design

The server is capable of handling multiple clients at the same time. Each client is handled by a separate thread, which is responsible for handling the requests from that client; once the client disconnects, the thread is terminated and joins the main thread.

The server implements a series of optimizations to improve performance and reduce load. These are implemented at the persistence layer (the database) and come in the form of __caching__, __lazy loading__ and __batching__.

#### Caching

The server implements a series of performance optimizations to reduce the load on the database. One of these optimizations is __caching__. The server automatically caches in memory the most requested data, such as the channels.

To determine the channels that should be cached, the server keeps track of each channel's "_relevance score_" in the network. The more relevant a channel is (meaning, the higher the relevance score), the bigger the chance that it will be cached. The relevance score is calculated based on the following factors, each with it's own weight:

- __Number of users__: the more users a channel has, the more relevant it is (50%).
- __Request Count__: the more requests a channel has, the more relevant it is (30%).
- __Last Request__: the more recent the last request, the more relevant it is (20%).

Additinaly, the relevance of a channel decays over time by a decay factor of `0.001` each second.

```csharp
private static float RateChannel(Channel channel)
{
    float decayFactor = (float)Math.Pow(1f - channel._channelRelevanceDecay, TimeSinceLastRequest(channel) / channel._channelRelevanceDecayRate);

    float relevanceScore = (channel._amountOfUsersWeight * channel._clients.Count) +
                           (channel._requestCountWeight * channel._channelRequestCount) +
                           (channel._lastRequestWeight * decayFactor);

    return relevanceScore;
}
```

#### Lazy Loading

The server automatically caches the most requested data in memory. However, it is not possible to cache all the data in memory, as it would be too much. For this reason, the server implements __lazy loading__.

Lazy loading is a technique that defers the loading of data until it is needed. This means that the data is only loaded when it is requested by the client. This allows the server to only load the data that is needed, reducing the load on the database.

If a channel, or any other data is not present in the cache, the server will load it from the database. The server will then cache the data in memory for future requests if needed, or if the relevance score of that piece of data is high enough.

#### Batching

To reduce the number of writes to the database, the server implements __batching__. Batching is a technique that allows the server to group multiple writes into a single write. This reduces the number of writes to the database, therefore reducing the load.

The server implements batching by keeping track of all the writes that need to be flushed to the database. When the number of writes reaches a certain threshold, or the database flush timout is reached, the server will flush all the writes to the database.

### Server Flow

#### Initialization (_Bootstrap Procedure_)

The server starts by initializing the __bootstrap procedure__. This is where all configs are loaded from the config file, the database is initialized, data is cached, and the server is started.

> Before loading the configs, the server must first check if it is running for the first time; ideally, this would be made by creating a Windows Registry Key, however, for the sake of transparency and ease of deletion, the server instead checks if the file `C:\iplchat\server\startup.conf` is present. If not present, the server is assumed to be running for the first time.

The server can be configured by modifying the config file located at `C:\iplchat\server\config.conf`:

```ini

```

> __Note:__ Be aware that some of the configs will only be applied after the server is restarted. Like the server port, Database stuff, Logger stuff, etc.

After the configuration is loaded, the server initializes all of it's components, such as the database, the logger, the CLI, etc. Once all the components are initialized, the server starts listening for connections.

#### Connection Handling

When a client connects to the server, the server will create a new thread to handle that client. This thread will be responsible for handling all the requests from that client, until it disconnects.

#### Request Handling

When a client sends a request to the server, the server will attempt to create a new [ProtoPacket](https://joaoajmatos.github.io/ProtoIP/#/Packet) from the request.

The server than checks the packet headers to determine the type of request. Control packets are handled by the `HandleRequest` method, which orchestrates function calls depending on the request type.

```csharp
// Called when a request is received from a client
public override void OnRequest(int clientID)
{
    try
    {
        Packet receivedPacket = AssembleReceivedDataIntoPacket(clientID);
        HandleRequest(clientID, receivedPacket);
    }
    catch (System.Exception e)
    {
        // Logs the error              
    }
}

// Orchestrates function calls depending on the request type
private void HandleRequest(int clientID, Packet receivedPacket)
{
    IPLChat.Protocol.PacketType packetType = (IPLChat.Protocol.PacketType)receivedPacket._GetType();

    switch (packetType)
    {
    case IPLChat.Protocol.PacketType.HANDSHAKE_REQUEST:
        Handshake(clientID, receivedPacket);
        break;
    case IPLChat.Protocol.PacketType.NOTIFICATION_PORT:
        HandleNotificationPort(receivedPacket, clientID);
        break;
    case IPLChat.Protocol.PacketType.JOIN_CHANNEL_REQUEST:
        HandleJoinChannelRequest(receivedPacket, clientID);
        break;
    case IPLChat.Protocol.PacketType.MESSAGE_REQUEST:
        HandleMessage(receivedPacket, clientID);
        break;
    case IPLChat.Protocol.PacketType.MESSAGE_SYNC_REQUEST:
        HandleMessageSyncRequest(receivedPacket, clientID);
        break;
    // ...
    // ... More requests
    // ...
    default:
        _logger.Log("Server received unknown or unexpected packet type: " + (int)packetType + " (" + packetType + ") from client " + clientID, Logger.Level.WARNING);
        break;
    }
}
```

<br>

Every client has it's own client ID. This ID is independent from the client's UUID. While the first is used to identify the index of the client in the server's __ProtoStream__ connection list (_refer to [ProtoStreams](https://joaoajmatos.github.io/ProtoIP/#/ProtoStream)_), the second is used to identify the client inside of the application environment.

> __ProtoStreams__ allow you to send large chunks of data in a single function call, without having to worry about packet fragmentation, or even data loss. If the data is too big, ProtoStreams automatically accommodate the data into multiple indexed packets, and reassemble them on the other end. All while being able to detect packet loss, and re-request the missing packets. This is all done automatically, without any extra work from the developer. This is one of the reasons why ProtoIP is so beginner friendly.

#### Handshake

When a client connects to the server, it must first perform a handshake. This is where the client exchanges cryptographic keys with the server. We use __RSA__ to exchange the keys, and __AES__ to encrypt the data.

The client starts by generating a new RSA key pair. It then sends the public key to the server, which will use it to encrypt the AES key. The server then sends the encrypted AES key to the client, which will decrypt it using it's private key. Both the client and the server now have the same AES key, which they will use to encrypt and decrypt all the data sent between them.

#### Push Notifications

For the sake of simplicity and ease of use, ProtoIP (as of now) does not support asynchronous socket I/O. Meaning that all the communications between the client and the server are synchronous (and therefore blocking), even if the server is multithreaded.

This emposes a problem when trying to notify the client of new messages or new events such as a user joining a chanel.

It would be impractical to have the client constantly polling the server for new messages, as this would be a waste of resources. For this reason, the server implements __push notifications__.

Every client has a notification port, chosen at random at runtime. This port is used by the server to send notifications to. When a client successfully performs a handshake with the server, and is authenticated, it will send the server it's notification port. The server will then use this port to send notifications to the client via ProtoIP's __NotificationPusher__.

> __NotificationPusher__ is a class that allows you to send notifications to a client via a ProtoStream. It is a wrapper around ProtoIP's __ProtoClient__ class, and it's only purpose is to send notifications to a client.

#### Message Handling

